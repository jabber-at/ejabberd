diff --git a/src/ejabberd_c2s.erl b/src/ejabberd_c2s.erl
index c21683f..2ff72e3 100644
--- a/src/ejabberd_c2s.erl
+++ b/src/ejabberd_c2s.erl
@@ -2878,7 +2878,16 @@ handle_unacked_stanzas(StateData)
 		      ?DEBUG("Dropping forwarded message stanza from ~s",
 			     [xml:get_attr_s(<<"from">>, El#xmlel.attrs)]);
 		  false ->
-		      ReRoute(From, To, El, Time)
+		      case ejabberd_hooks:run_fold(message_is_archived,
+						   StateData#state.server,
+						   false,
+						   [StateData, From,
+						    StateData#state.jid, El]) of
+			true ->
+			    ok;
+			false ->
+			    ReRoute(From, To, El, Time)
+		      end
 		end
 	end,
     handle_unacked_stanzas(StateData, F);
diff --git a/src/mod_mam.erl b/src/mod_mam.erl
index f334152..15d0ebe 100644
--- a/src/mod_mam.erl
+++ b/src/mod_mam.erl
@@ -36,12 +36,23 @@
 -export([user_send_packet/4, user_receive_packet/5,
 	 process_iq_v0_2/3, process_iq_v0_3/3, disco_sm_features/5,
 	 remove_user/2, remove_user/3, mod_opt_type/1, muc_process_iq/4,
-	 muc_filter_message/5]).
+	 muc_filter_message/5, message_is_archived/5, delete_old_messages/2]).
 
 -include_lib("stdlib/include/ms_transform.hrl").
 -include("jlib.hrl").
 -include("logger.hrl").
 -include("mod_muc_room.hrl").
+-include("ejabberd_commands.hrl").
+
+-define(DEF_PAGE_SIZE, 50).
+-define(MAX_PAGE_SIZE, 250).
+
+-define(BIN_GREATER_THAN(A, B),
+	((A > B andalso byte_size(A) == byte_size(B))
+	 orelse byte_size(A) > byte_size(B))).
+-define(BIN_LESS_THAN(A, B),
+	((A < B andalso byte_size(A) == byte_size(B))
+	 orelse byte_size(A) < byte_size(B))).
 
 -record(archive_msg,
 	{us = {<<"">>, <<"">>}                :: {binary(), binary()} | '$2',
@@ -94,6 +105,18 @@ start(Host, Opts) ->
 		       remove_user, 50),
     ejabberd_hooks:add(anonymous_purge_hook, Host, ?MODULE,
 		       remove_user, 50),
+    case gen_mod:get_opt(assume_mam_usage, Opts,
+			 fun(if_enabled) -> if_enabled;
+			    (on_request) -> on_request;
+			    (never) -> never
+			 end, never) of
+	never ->
+	    ok;
+	_ ->
+	    ejabberd_hooks:add(message_is_archived, Host, ?MODULE,
+			       message_is_archived, 50)
+    end,
+    ejabberd_commands:register_commands(commands()),
     ok.
 
 init_db(mnesia, _Host) ->
@@ -138,6 +161,18 @@ stop(Host) ->
 			  remove_user, 50),
     ejabberd_hooks:delete(anonymous_purge_hook, Host,
 			  ?MODULE, remove_user, 50),
+    case gen_mod:get_module_opt(Host, ?MODULE, assume_mam_usage,
+				fun(if_enabled) -> if_enabled;
+				   (on_request) -> on_request;
+				   (never) -> never
+				end, never) of
+	never ->
+	    ok;
+	_ ->
+	    ejabberd_hooks:delete(message_is_archived, Host, ?MODULE,
+				  message_is_archived, 50)
+    end,
+    ejabberd_commands:unregister_commands(commands()),
     ok.
 
 remove_user(User, Server) ->
@@ -208,11 +243,15 @@ muc_filter_message(Pkt, #state{config = Config} = MUCState,
 	    NewPkt = strip_my_archived_tag(Pkt, LServer),
 	    case store_muc(MUCState, NewPkt, RoomJID, From, FromNick) of
 		{ok, ID} ->
+		    Archived = #xmlel{name = <<"archived">>,
+				      attrs = [{<<"by">>, LServer},
+					       {<<"xmlns">>, ?NS_MAM_TMP},
+					       {<<"id">>, ID}]},
 		    StanzaID = #xmlel{name = <<"stanza-id">>,
 				      attrs = [{<<"by">>, LServer},
                                                {<<"xmlns">>, ?NS_SID_0},
                                                {<<"id">>, ID}]},
-                    NewEls = [StanzaID|NewPkt#xmlel.children],
+                    NewEls = [Archived, StanzaID|NewPkt#xmlel.children],
                     NewPkt#xmlel{children = NewEls};
 		_ ->
 		    NewPkt
@@ -225,20 +264,7 @@ muc_filter_message(Pkt, #state{config = Config} = MUCState,
 process_iq_v0_2(#jid{lserver = LServer} = From,
 	       #jid{lserver = LServer} = To,
 	       #iq{type = get, sub_el = #xmlel{name = <<"query">>} = SubEl} = IQ) ->
-    Fs = lists:flatmap(
-	    fun (#xmlel{name = <<"start">>} = El) ->
-		    [{<<"start">>, [xml:get_tag_cdata(El)]}];
-		(#xmlel{name = <<"end">>} = El) ->
-		    [{<<"end">>, [xml:get_tag_cdata(El)]}];
-		(#xmlel{name = <<"with">>} = El) ->
-		    [{<<"with">>, [xml:get_tag_cdata(El)]}];
-		(#xmlel{name = <<"withtext">>} = El) ->
-		    [{<<"withtext">>, [xml:get_tag_cdata(El)]}];
-		(#xmlel{name = <<"set">>}) ->
-		    [{<<"set">>, SubEl}];
-		(_) ->
-		   []
-	   end, SubEl#xmlel.children),
+    Fs = parse_query_v0_2(SubEl),
     process_iq(LServer, From, To, IQ, SubEl, Fs, chat);
 process_iq_v0_2(From, To, IQ) ->
     process_iq(From, To, IQ).
@@ -248,35 +274,33 @@ process_iq_v0_3(#jid{lserver = LServer} = From,
 		#jid{lserver = LServer} = To,
 		#iq{type = set, sub_el = #xmlel{name = <<"query">>} = SubEl} = IQ) ->
     process_iq(LServer, From, To, IQ, SubEl, get_xdata_fields(SubEl), chat);
+process_iq_v0_3(#jid{lserver = LServer},
+		#jid{lserver = LServer},
+		#iq{type = get, sub_el = #xmlel{name = <<"query">>}} = IQ) ->
+    process_iq(LServer, IQ);
 process_iq_v0_3(From, To, IQ) ->
     process_iq(From, To, IQ).
 
-muc_process_iq(#iq{type = set, lang = Lang,
+muc_process_iq(#iq{type = set,
+		   sub_el = #xmlel{name = <<"query">>,
+				   attrs = Attrs} = SubEl} = IQ,
+	       MUCState, From, To) ->
+    case xml:get_attr_s(<<"xmlns">>, Attrs) of
+	NS when NS == ?NS_MAM_0; NS == ?NS_MAM_1 ->
+	    muc_process_iq(IQ, MUCState, From, To, get_xdata_fields(SubEl));
+	_ ->
+	    IQ
+    end;
+muc_process_iq(#iq{type = get,
 		   sub_el = #xmlel{name = <<"query">>,
 				   attrs = Attrs} = SubEl} = IQ,
 	       MUCState, From, To) ->
     case xml:get_attr_s(<<"xmlns">>, Attrs) of
-	?NS_MAM_0 ->
+	?NS_MAM_TMP ->
+	    muc_process_iq(IQ, MUCState, From, To, parse_query_v0_2(SubEl));
+	NS when NS == ?NS_MAM_0; NS == ?NS_MAM_1 ->
 	    LServer = MUCState#state.server_host,
-	    Role = mod_muc_room:get_role(From, MUCState),
-	    Config = MUCState#state.config,
-	    if Config#config.members_only ->
-		    case mod_muc_room:is_occupant_or_admin(From, MUCState) of
-			true ->
-			    process_iq(LServer, From, To, IQ, SubEl,
-				       get_xdata_fields(SubEl),
-				       {groupchat, Role, MUCState});
-			false ->
-			    Text = <<"Only members are allowed to query "
-				     "archives of this room">>,
-			    Error = ?ERRT_FORBIDDEN(Lang, Text),
-			    IQ#iq{type = error, sub_el = [SubEl, Error]}
-		    end;
-	       true ->
-		    process_iq(LServer, From, To, IQ, SubEl,
-			       get_xdata_fields(SubEl),
-			       {groupchat, Role, MUCState})
-	    end;
+	    process_iq(LServer, IQ);
 	_ ->
 	    IQ
     end;
@@ -305,10 +329,119 @@ disco_sm_features({result, OtherFeatures},
 disco_sm_features(Acc, _From, _To, _Node, _Lang) ->
     Acc.
 
+message_is_archived(true, _C2SState, _Peer, _JID, _Pkt) ->
+    true;
+message_is_archived(false, C2SState, Peer,
+		    #jid{luser = LUser, lserver = LServer}, Pkt) ->
+    Res = case gen_mod:get_module_opt(LServer, ?MODULE, assume_mam_usage,
+				      fun(if_enabled) -> if_enabled;
+					 (on_request) -> on_request;
+					 (never) -> never
+				      end, never) of
+	      if_enabled ->
+		  get_prefs(LUser, LServer);
+	      on_request ->
+		  DBType = gen_mod:db_type(LServer, ?MODULE),
+		  cache_tab:lookup(archive_prefs, {LUser, LServer},
+				   fun() ->
+					   get_prefs(LUser, LServer, DBType)
+				   end);
+	      never ->
+		  error
+	  end,
+    case Res of
+	{ok, Prefs} ->
+	    should_archive(strip_my_archived_tag(Pkt, LServer), LServer)
+		andalso should_archive_peer(C2SState, Prefs, Peer);
+	error ->
+	    false
+    end.
+
+delete_old_messages(TypeBin, Days) when TypeBin == <<"chat">>;
+					TypeBin == <<"groupchat">>;
+					TypeBin == <<"all">> ->
+    Diff = Days * 24 * 60 * 60 * 1000000,
+    TimeStamp = usec_to_now(p1_time_compat:system_time(micro_seconds) - Diff),
+    Type = jlib:binary_to_atom(TypeBin),
+    {Results, _} =
+	lists:foldl(fun(Host, {Results, MnesiaDone}) ->
+			    case {gen_mod:db_type(Host, ?MODULE), MnesiaDone} of
+				{mnesia, true} ->
+				    {Results, true};
+				{mnesia, false} ->
+				    Res = delete_old_messages(TimeStamp, Type,
+							      global, mnesia),
+				    {[Res|Results], true};
+				{DBType, _} ->
+				    Res = delete_old_messages(TimeStamp, Type,
+							      Host, DBType),
+				    {[Res|Results], MnesiaDone}
+			    end
+		    end, {[], false}, ?MYHOSTS),
+    case lists:filter(fun(Res) -> Res /= ok end, Results) of
+	[] -> ok;
+	[NotOk|_] -> NotOk
+    end;
+delete_old_messages(_TypeBin, _Days) ->
+    unsupported_type.
+
+delete_old_messages(TimeStamp, Type, global, mnesia) ->
+    MS = ets:fun2ms(fun(#archive_msg{timestamp = MsgTS,
+				     type = MsgType} = Msg)
+			    when MsgTS < TimeStamp,
+				 MsgType == Type orelse Type == all ->
+			    Msg
+		    end),
+    OldMsgs = mnesia:dirty_select(archive_msg, MS),
+    lists:foreach(fun(Rec) ->
+			  ok = mnesia:dirty_delete_object(Rec)
+		  end, OldMsgs);
+delete_old_messages(_TimeStamp, _Type, _Host, _DBType) ->
+    %% TODO
+    not_implemented.
+
 %%%===================================================================
 %%% Internal functions
 %%%===================================================================
 
+process_iq(LServer, #iq{sub_el = #xmlel{attrs = Attrs}} = IQ) ->
+    NS = case xml:get_attr_s(<<"xmlns">>, Attrs) of
+	     ?NS_MAM_0 ->
+		 ?NS_MAM_0;
+	     _ ->
+		 ?NS_MAM_1
+	 end,
+    CommonFields = [#xmlel{name = <<"field">>,
+			   attrs = [{<<"type">>, <<"hidden">>},
+				    {<<"var">>, <<"FORM_TYPE">>}],
+			   children = [#xmlel{name = <<"value">>,
+					      children = [{xmlcdata, NS}]}]},
+		    #xmlel{name = <<"field">>,
+			   attrs = [{<<"type">>, <<"jid-single">>},
+				    {<<"var">>, <<"with">>}]},
+		    #xmlel{name = <<"field">>,
+			   attrs = [{<<"type">>, <<"text-single">>},
+				    {<<"var">>, <<"start">>}]},
+		    #xmlel{name = <<"field">>,
+			   attrs = [{<<"type">>, <<"text-single">>},
+				    {<<"var">>, <<"end">>}]}],
+    Fields = case gen_mod:db_type(LServer, ?MODULE) of
+		 odbc ->
+		     WithText = #xmlel{name = <<"field">>,
+				       attrs = [{<<"type">>, <<"text-single">>},
+						{<<"var">>, <<"withtext">>}]},
+		     [WithText|CommonFields];
+		 _ ->
+		     CommonFields
+	     end,
+    Form = #xmlel{name = <<"x">>,
+		  attrs = [{<<"xmlns">>, ?NS_XDATA}, {<<"type">>, <<"form">>}],
+		  children = Fields},
+    IQ#iq{type = result,
+	  sub_el = [#xmlel{name = <<"query">>,
+			   attrs = [{<<"xmlns">>, NS}],
+			   children = [Form]}]}.
+
 % Preference setting (both v0.2 & v0.3)
 process_iq(#jid{luser = LUser, lserver = LServer},
 	   #jid{lserver = LServer},
@@ -360,7 +493,13 @@ process_iq(#jid{luser = LUser, lserver = LServer},
 process_iq(_, _, #iq{sub_el = SubEl} = IQ) ->
     IQ#iq{type = error, sub_el = [SubEl, ?ERR_NOT_ALLOWED]}.
 
-process_iq(LServer, From, To, IQ, SubEl, Fs, MsgType) ->
+process_iq(LServer, #jid{luser = LUser} = From, To, IQ, SubEl, Fs, MsgType) ->
+    case MsgType of
+	chat ->
+	    maybe_activate_mam(LUser, LServer);
+	{groupchat, _Role, _MUCState} ->
+	    ok
+    end,
     case catch lists:foldl(
 		 fun({<<"start">>, [Data|_]}, {_, End, With, RSM}) ->
 			 {{_, _, _} = jlib:datetime_string_to_timestamp(Data),
@@ -380,11 +519,46 @@ process_iq(LServer, From, To, IQ, SubEl, Fs, MsgType) ->
 		 end, {none, [], none, none}, Fs) of
 	{'EXIT', _} ->
 	    IQ#iq{type = error, sub_el = [SubEl, ?ERR_BAD_REQUEST]};
+	{_Start, _End, _With, #rsm_in{index = Index}} when is_integer(Index) ->
+	    IQ#iq{type = error, sub_el = [SubEl, ?ERR_FEATURE_NOT_IMPLEMENTED]};
 	{Start, End, With, RSM} ->
+	    NS = xml:get_tag_attr_s(<<"xmlns">>, SubEl),
 	    select_and_send(LServer, From, To, Start, End,
-			    With, RSM, IQ, MsgType)
+			    With, limit_max(RSM, NS), IQ, MsgType)
+    end.
+
+muc_process_iq(#iq{lang = Lang, sub_el = SubEl} = IQ,
+	       #state{config = #config{members_only = MembersOnly}} = MUCState,
+	       From, To, Fs) ->
+    case not MembersOnly orelse
+	mod_muc_room:is_occupant_or_admin(From, MUCState) of
+	true ->
+	    LServer = MUCState#state.server_host,
+	    Role = mod_muc_room:get_role(From, MUCState),
+	    process_iq(LServer, From, To, IQ, SubEl, Fs,
+		       {groupchat, Role, MUCState});
+	false ->
+	    Text = <<"Only members may query archives of this room">>,
+	    Error = ?ERRT_FORBIDDEN(Lang, Text),
+	    IQ#iq{type = error, sub_el = [SubEl, Error]}
     end.
 
+parse_query_v0_2(Query) ->
+    lists:flatmap(
+      fun (#xmlel{name = <<"start">>} = El) ->
+	      [{<<"start">>, [xml:get_tag_cdata(El)]}];
+	  (#xmlel{name = <<"end">>} = El) ->
+	      [{<<"end">>, [xml:get_tag_cdata(El)]}];
+	  (#xmlel{name = <<"with">>} = El) ->
+	      [{<<"with">>, [xml:get_tag_cdata(El)]}];
+	  (#xmlel{name = <<"withtext">>} = El) ->
+	      [{<<"withtext">>, [xml:get_tag_cdata(El)]}];
+	  (#xmlel{name = <<"set">>}) ->
+	      [{<<"set">>, Query}];
+	  (_) ->
+	     []
+      end, Query#xmlel.children).
+
 should_archive(#xmlel{name = <<"message">>} = Pkt, LServer) ->
     case xml:get_attr_s(<<"type">>, Pkt#xmlel.attrs) of
 	<<"error">> ->
@@ -461,9 +635,30 @@ should_archive_peer(C2SState,
 	    end
     end.
 
-should_archive_muc(_MUCState, _Peer) ->
-    %% TODO
-    true.
+should_archive_muc(Pkt) ->
+    case xml:get_attr_s(<<"type">>, Pkt#xmlel.attrs) of
+	<<"groupchat">> ->
+	    case check_store_hint(Pkt) of
+		store ->
+		    true;
+		no_store ->
+		    false;
+		none ->
+		    case xml:get_subtag_cdata(Pkt, <<"body">>) of
+			<<>> ->
+			    case xml:get_subtag_cdata(Pkt, <<"subject">>) of
+				<<>> ->
+				    false;
+				_ ->
+				    true
+			    end;
+			_ ->
+			    true
+		    end
+	    end;
+	_ ->
+	    false
+    end.
 
 check_store_hint(Pkt) ->
     case has_store_hint(Pkt) of
@@ -517,7 +712,7 @@ store_msg(C2SState, Pkt, LUser, LServer, Peer, Dir) ->
     end.
 
 store_muc(MUCState, Pkt, RoomJID, Peer, Nick) ->
-    case should_archive_muc(MUCState, Peer) of
+    case should_archive_muc(Pkt) of
 	true ->
 	    LServer = MUCState#state.server_host,
 	    {U, S, _} = jid:tolower(RoomJID),
@@ -620,13 +815,21 @@ get_prefs(LUser, LServer) ->
 	{ok, Prefs} ->
 	    Prefs;
 	error ->
-	    Default = gen_mod:get_module_opt(
-		    LServer, ?MODULE, default,
-		    fun(always) -> always;
-			(never) -> never;
-			(roster) -> roster
-		    end, never),
-	    #archive_prefs{us = {LUser, LServer}, default = Default}
+	    ActivateOpt = gen_mod:get_module_opt(
+			    LServer, ?MODULE, request_activates_archiving,
+			    fun(B) when is_boolean(B) -> B end, false),
+	    case ActivateOpt of
+		true ->
+		    #archive_prefs{us = {LUser, LServer}, default = never};
+		false ->
+		    Default = gen_mod:get_module_opt(
+				LServer, ?MODULE, default,
+				fun(always) -> always;
+				   (never) -> never;
+				   (roster) -> roster
+				end, never),
+		    #archive_prefs{us = {LUser, LServer}, default = Default}
+	    end
     end.
 
 get_prefs(LUser, LServer, mnesia) ->
@@ -654,6 +857,34 @@ get_prefs(LUser, LServer, odbc) ->
 	    error
     end.
 
+maybe_activate_mam(LUser, LServer) ->
+    ActivateOpt = gen_mod:get_module_opt(LServer, ?MODULE,
+					 request_activates_archiving,
+					 fun(B) when is_boolean(B) -> B end,
+					 false),
+    case ActivateOpt of
+	true ->
+	    Res = cache_tab:lookup(archive_prefs, {LUser, LServer},
+				   fun() ->
+					   get_prefs(LUser, LServer,
+						     gen_mod:db_type(LServer,
+								     ?MODULE))
+				   end),
+	    case Res of
+		{ok, _Prefs} ->
+		    ok;
+		error ->
+		    Default = gen_mod:get_module_opt(LServer, ?MODULE, default,
+						     fun(always) -> always;
+							(never) -> never;
+							(roster) -> roster
+						     end, never),
+		    write_prefs(LUser, LServer, LServer, Default, [], [])
+	    end;
+	false ->
+	    ok
+    end.
+
 select_and_send(LServer, From, To, Start, End, With, RSM, IQ, MsgType) ->
     DBType = case gen_mod:db_type(LServer, ?MODULE) of
 		 odbc -> {odbc, LServer};
@@ -717,7 +948,8 @@ select(_LServer, #jid{luser = LUser, lserver = LServer} = JidRequestor,
        Start, End, With, RSM, MsgType, mnesia) ->
     MS = make_matchspec(LUser, LServer, Start, End, With),
     Msgs = mnesia:dirty_select(archive_msg, MS),
-    {FilteredMsgs, IsComplete} = filter_by_rsm(Msgs, RSM),
+    SortedMsgs = lists:keysort(#archive_msg.timestamp, Msgs),
+    {FilteredMsgs, IsComplete} = filter_by_rsm(SortedMsgs, RSM),
     Count = length(Msgs),
     {lists:map(
        fun(Msg) ->
@@ -733,12 +965,12 @@ select(LServer, #jid{luser = LUser} = JidRequestor,
 	   end,
     {Query, CountQuery} = make_sql_query(User, LServer,
 					 Start, End, With, RSM),
-    % XXX TODO from XEP-0313:
-    % To conserve resources, a server MAY place a reasonable limit on
-    % how many stanzas may be pushed to a client in one request. If a
-    % query returns a number of stanzas greater than this limit and
-    % the client did not specify a limit using RSM then the server
-    % should return a policy-violation error to the client.
+    % TODO from XEP-0313 v0.2: "To conserve resources, a server MAY place a
+    % reasonable limit on how many stanzas may be pushed to a client in one
+    % request. If a query returns a number of stanzas greater than this limit
+    % and the client did not specify a limit using RSM then the server should
+    % return a policy-violation error to the client." We currently don't do this
+    % for v0.2 requests, but we do limit #rsm_in.max for v0.3 and newer.
     case {ejabberd_odbc:sql_query(Host, Query),
 	  ejabberd_odbc:sql_query(Host, CountQuery)} of
 	{{selected, _, Res}, {selected, _, [[Count]]}} ->
@@ -789,27 +1021,14 @@ select(LServer, #jid{luser = LUser} = JidRequestor,
     end.
 
 msg_to_el(#archive_msg{timestamp = TS, packet = Pkt1, nick = Nick, peer = Peer},
-	  MsgType, JidRequestor) ->
-    Delay = jlib:now_to_utc_string(TS),
-    Pkt = maybe_update_from_to(Pkt1, JidRequestor, Peer, MsgType, Nick),
-    #xmlel{name = <<"forwarded">>,
-	   attrs = [{<<"xmlns">>, ?NS_FORWARD}],
-	   children = [#xmlel{name = <<"delay">>,
-			      attrs = [{<<"xmlns">>, ?NS_DELAY},
-				       {<<"stamp">>, Delay}]},
-		       xml:replace_tag_attr(
-			 <<"xmlns">>, <<"jabber:client">>, Pkt)]}.
-
-maybe_update_from_to(Pkt, JidRequestor, Peer, chat, _Nick) ->
-    case xml:get_attr_s(<<"type">>, Pkt#xmlel.attrs) of
-	<<"groupchat">> when Peer /= undefined ->
-	    Pkt2 = xml:replace_tag_attr(<<"to">>,
-					jid:to_string(JidRequestor),
-					Pkt),
-	    xml:replace_tag_attr(<<"from">>, jid:to_string(Peer),
-				 Pkt2);
-	_ -> Pkt
-    end;
+	  MsgType, #jid{lserver = LServer} = JidRequestor) ->
+    Pkt2 = maybe_update_from_to(Pkt1, JidRequestor, Peer, MsgType, Nick),
+    Pkt3 = #xmlel{name = <<"forwarded">>,
+		  attrs = [{<<"xmlns">>, ?NS_FORWARD}],
+		  children = [xml:replace_tag_attr(
+				<<"xmlns">>, <<"jabber:client">>, Pkt2)]},
+    jlib:add_delay_info(Pkt3, LServer, TS).
+
 maybe_update_from_to(#xmlel{children = Els} = Pkt, JidRequestor,
 		     Peer, {groupchat, Role, _MUCState}, Nick) ->
     Items = case Role of
@@ -825,7 +1044,9 @@ maybe_update_from_to(#xmlel{children = Els} = Pkt, JidRequestor,
 	    end,
     Pkt1 = Pkt#xmlel{children = Items ++ Els},
     Pkt2 = jlib:replace_from(jid:replace_resource(JidRequestor, Nick), Pkt1),
-    jlib:remove_attr(<<"to">>, Pkt2).
+    jlib:remove_attr(<<"to">>, Pkt2);
+maybe_update_from_to(Pkt, _JidRequestor, _Peer, chat, _Nick) ->
+    Pkt.
 
 is_bare_copy(#jid{luser = U, lserver = S, lresource = R}, To) ->
     PrioRes = ejabberd_sm:get_user_present_resources(U, S),
@@ -926,11 +1147,12 @@ filter_by_rsm(Msgs, #rsm_in{max = Max, direction = Direction, id = ID}) ->
 		  aft when ID /= <<"">> ->
 		      lists:filter(
 			fun(#archive_msg{id = I}) ->
-				I > ID
+				?BIN_GREATER_THAN(I, ID)
 			end, Msgs);
 		  before when ID /= <<"">> ->
 		      lists:foldl(
-			fun(#archive_msg{id = I} = Msg, Acc) when I < ID ->
+			fun(#archive_msg{id = I} = Msg, Acc)
+				when ?BIN_LESS_THAN(I, ID) ->
 				[Msg|Acc];
 			   (_, Acc) ->
 				Acc
@@ -949,6 +1171,15 @@ filter_by_max(Msgs, Len) when is_integer(Len), Len >= 0 ->
 filter_by_max(_Msgs, _Junk) ->
     {[], true}.
 
+limit_max(RSM, ?NS_MAM_TMP) ->
+    RSM; % XEP-0313 v0.2 doesn't require clients to support RSM.
+limit_max(#rsm_in{max = Max} = RSM, _NS) when not is_integer(Max) ->
+    RSM#rsm_in{max = ?DEF_PAGE_SIZE};
+limit_max(#rsm_in{max = Max} = RSM, _NS) when Max > ?MAX_PAGE_SIZE ->
+    RSM#rsm_in{max = ?MAX_PAGE_SIZE};
+limit_max(RSM, _NS) ->
+    RSM.
+
 match_interval(Now, Start, End) ->
     (Now >= Start) and (Now =< End).
 
@@ -1120,6 +1351,20 @@ update(LServer, Table, Fields, Vals, Where) ->
 join([], _Sep) -> [];
 join([H | T], Sep) -> [H, [[Sep, X] || X <- T]].
 
+commands() ->
+    [#ejabberd_commands{name = delete_old_mam_messages, tags = [purge],
+			desc = "Delete MAM messages older than DAYS",
+			longdesc = "Valid message TYPEs: "
+				   "\"chat\", \"groupchat\", \"all\".",
+			module = ?MODULE, function = delete_old_messages,
+			args = [{type, binary}, {days, integer}],
+			result = {res, rescode}}].
+
+mod_opt_type(assume_mam_usage) ->
+    fun(if_enabled) -> if_enabled;
+       (on_request) -> on_request;
+       (never) -> never
+    end;
 mod_opt_type(cache_life_time) ->
     fun (I) when is_integer(I), I > 0 -> I end;
 mod_opt_type(cache_size) ->
@@ -1131,8 +1376,8 @@ mod_opt_type(default) ->
 	(roster) -> roster
     end;
 mod_opt_type(iqdisc) -> fun gen_iq_handler:check_type/1;
-mod_opt_type(store_body_only) ->
+mod_opt_type(request_activates_archiving) ->
     fun (B) when is_boolean(B) -> B end;
 mod_opt_type(_) ->
-    [cache_life_time, cache_size, db_type, default, iqdisc,
-     store_body_only].
+    [assume_mam_usage, cache_life_time, cache_size, db_type, default, iqdisc,
+     request_activates_archiving].
diff --git a/src/mod_muc.erl b/src/mod_muc.erl
index b03dde3..3765f8e 100644
--- a/src/mod_muc.erl
+++ b/src/mod_muc.erl
@@ -756,6 +756,8 @@ iq_disco_info(ServerHost, Lang) ->
 	case gen_mod:is_loaded(ServerHost, mod_mam) of
 	    true ->
 		[#xmlel{name = <<"feature">>,
+			attrs = [{<<"var">>, ?NS_MAM_TMP}]},
+		 #xmlel{name = <<"feature">>,
 			attrs = [{<<"var">>, ?NS_MAM_0}]},
 		 #xmlel{name = <<"feature">>,
 			attrs = [{<<"var">>, ?NS_MAM_1}]}];
diff --git a/src/mod_muc_room.erl b/src/mod_muc_room.erl
index 6dfda26..b9c8b71 100644
--- a/src/mod_muc_room.erl
+++ b/src/mod_muc_room.erl
@@ -4152,7 +4152,9 @@ process_iq_disco_info(_From, get, Lang, StateData) ->
        ++ case {gen_mod:is_loaded(StateData#state.server_host, mod_mam),
 		Config#config.mam} of
 	    {true, true} ->
-		[?FEATURE(?NS_MAM_0)];
+		[?FEATURE(?NS_MAM_TMP),
+		 ?FEATURE(?NS_MAM_0),
+		 ?FEATURE(?NS_MAM_1)];
 	    _ ->
 		[]
 	  end
