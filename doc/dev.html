<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="generator" content="hevea 2.09">
<style type="text/css">
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.footnotetext{margin:0ex; padding:0ex;}
div.footnotetext P{margin:0px; text-indent:1em;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:2ex auto;text-align:center}
.titlemain{margin:1ex 2ex 2ex 1ex;}
.titlerest{margin:0ex 2ex;}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
div table{margin-left:inherit;margin-right:inherit;margin-bottom:2px;margin-top:2px}
td table{margin:auto;}
table{border-collapse:collapse;}
td{padding:0;}
.cellpadding0 tr td{padding:0;}
.cellpadding1 tr td{padding:1px;}
pre{text-align:left;margin-left:0ex;margin-right:auto;}
blockquote{margin-left:4ex;margin-right:4ex;text-align:left;}
td p{margin:0px;}
.boxed{border:1px solid black}
.textboxed{border:1px solid black}
.vbar{border:none;width:2px;background-color:black;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
.hfill{border:none;height:1px;width:200%;background-color:black;}
.vdisplay{border-collapse:separate;border-spacing:2px;width:auto; empty-cells:show; border:2px solid red;}
.vdcell{white-space:nowrap;padding:0px; border:2px solid green;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px; border:none;}
.dcenter{margin:0ex auto;}
.vdcenter{border:solid #FF8000 2px; margin:0ex auto;}
.minipage{text-align:left; margin-left:0em; margin-right:auto;}
.marginpar{border:solid thin black; width:20%; text-align:left;}
.marginparleft{float:left; margin-left:0ex; margin-right:1ex;}
.marginparright{float:right; margin-left:1ex; margin-right:0ex;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.part{margin:2ex auto;text-align:center}
</style>
<title>Ejabberd community 14.05-120-gedfb5fc Developers Guide
</title>
</head>
<body >
<!--HEVEA command line is: /usr/bin/hevea -fix -pedantic dev.tex -->
<!--CUT STYLE article--><!--CUT DEF section 1 --><p><a id="titlepage"></a>

</p><table class="title"><tr><td style="padding:1ex"><h1 class="titlemain">Ejabberd community 14.05-120-gedfb5fc Developers Guide</h1><h3 class="titlerest">Alexey Shchepin <br>
 <a href="mailto:alexey@sevcom.net"><span style="font-family:monospace">mailto:alexey@sevcom.net</span></a> <br>
 <a href="xmpp:aleksey@jabber.ru"><span style="font-family:monospace">xmpp:aleksey@jabber.ru</span></a></h3></td></tr>
</table><div class="center">

<img src="logo.png" alt="logo.png">


</div><blockquote class="quotation"><span style="font-style:italic">I can thoroughly recommend ejabberd for ease of setup &#X2013;
Kevin Smith, Current maintainer of the Psi project</span></blockquote><!--TOC section id="intro" Contents-->
<h2 id="intro" class="section">Contents</h2><!--SEC END --><ul class="toc"><li class="li-toc">
<a href="#sec2">1&#XA0;&#XA0;Key Features</a>
</li><li class="li-toc"><a href="#sec3">2&#XA0;&#XA0;Additional Features</a>
</li><li class="li-toc"><a href="#sec4">3&#XA0;&#XA0;How it Works</a>
<ul class="toc"><li class="li-toc">
<a href="#sec5">3.1&#XA0;&#XA0;Router</a>
</li><li class="li-toc"><a href="#sec6">3.2&#XA0;&#XA0;Local Router</a>
</li><li class="li-toc"><a href="#sec7">3.3&#XA0;&#XA0;Session Manager</a>
</li><li class="li-toc"><a href="#sec8">3.4&#XA0;&#XA0;S2S Manager</a>
</li></ul>
</li><li class="li-toc"><a href="#sec9">4&#XA0;&#XA0;Authentication</a>
<ul class="toc">
<ul class="toc"><li class="li-toc">
<a href="#sec10">4.0.1&#XA0;&#XA0;External</a>
</li></ul>
</ul>
</li><li class="li-toc"><a href="#sec11">5&#XA0;&#XA0;XML Representation</a>
</li><li class="li-toc"><a href="#sec12">6&#XA0;&#XA0;Module <span style="font-family:monospace">xml</span></a>
</li><li class="li-toc"><a href="#sec13">7&#XA0;&#XA0;Module <span style="font-family:monospace">xml_stream</span></a>
</li><li class="li-toc"><a href="#sec14">8&#XA0;&#XA0;Modules</a>
<ul class="toc"><li class="li-toc">
<a href="#sec15">8.1&#XA0;&#XA0;Module gen_iq_handler</a>
</li><li class="li-toc"><a href="#sec16">8.2&#XA0;&#XA0;Services</a>
</li></ul>
</li></ul><p>Introduction
</p><p><span style="font-family:monospace">ejabberd</span> is a free and open source instant messaging server written in <a href="http://www.erlang.org/">Erlang/OTP</a>.</p><p><span style="font-family:monospace">ejabberd</span> is cross-platform, distributed, fault-tolerant, and based on open standards to achieve real-time communication.</p><p><span style="font-family:monospace">ejabberd</span> is designed to be a rock-solid and feature rich XMPP server.</p><p><span style="font-family:monospace">ejabberd</span> is suitable for small deployments, whether they need to be scalable or not, as well as extremely big deployments.</p>
<!--TOC section id="sec2" Key Features-->
<h2 id="sec2" class="section">1&#XA0;&#XA0;Key Features</h2><!--SEC END --><p>
<a id="keyfeatures"></a>
</p><p><span style="font-family:monospace">ejabberd</span> is:
</p><ul class="itemize"><li class="li-itemize">
Cross-platform: <span style="font-family:monospace">ejabberd</span> runs under Microsoft Windows and Unix derived systems such as Linux, FreeBSD and NetBSD.</li><li class="li-itemize">Distributed: You can run <span style="font-family:monospace">ejabberd</span> on a cluster of machines and all of them will serve the same Jabber domain(s). When you need more capacity you can simply add a new cheap node to your cluster. Accordingly, you do not need to buy an expensive high-end machine to support tens of thousands concurrent users.</li><li class="li-itemize">Fault-tolerant: You can deploy an <span style="font-family:monospace">ejabberd</span> cluster so that all the information required for a properly working service will be replicated permanently on all nodes. This means that if one of the nodes crashes, the others will continue working without disruption. In addition, nodes also can be added or replaced &#X2018;on the fly&#X2019;.</li><li class="li-itemize">Administrator Friendly: <span style="font-family:monospace">ejabberd</span> is built on top of the Open Source Erlang. As a result you do not need to install an external database, an external web server, amongst others because everything is already included, and ready to run out of the box. Other administrator benefits include:
<ul class="itemize"><li class="li-itemize">
Comprehensive documentation.
</li><li class="li-itemize">Straightforward installers for Linux, Mac OS X, and Windows. </li><li class="li-itemize">Web Administration.
</li><li class="li-itemize">Shared Roster Groups.
</li><li class="li-itemize">Command line administration tool. </li><li class="li-itemize">Can integrate with existing authentication mechanisms.
</li><li class="li-itemize">Capability to send announce messages.
</li></ul></li><li class="li-itemize">Internationalized: <span style="font-family:monospace">ejabberd</span> leads in internationalization. Hence it is very well suited in a globalized world. Related features are:
<ul class="itemize"><li class="li-itemize">
Translated to 25 languages. </li><li class="li-itemize">Support for <a href="http://www.ietf.org/rfc/rfc3490.txt">IDNA</a>.
</li></ul></li><li class="li-itemize">Open Standards: <span style="font-family:monospace">ejabberd</span> is the first Open Source Jabber server claiming to fully comply to the XMPP standard.
<ul class="itemize"><li class="li-itemize">
Fully XMPP compliant.
</li><li class="li-itemize">XML-based protocol.
</li><li class="li-itemize"><a href="http://www.ejabberd.im/protocols">Many protocols supported</a>.
</li></ul></li></ul>
<!--TOC section id="sec3" Additional Features-->
<h2 id="sec3" class="section">2&#XA0;&#XA0;Additional Features</h2><!--SEC END --><p>
<a id="addfeatures"></a>
</p><p>Moreover, <span style="font-family:monospace">ejabberd</span> comes with a wide range of other state-of-the-art features:
</p><ul class="itemize"><li class="li-itemize">
Modular
<ul class="itemize"><li class="li-itemize">
Load only the modules you want.
</li><li class="li-itemize">Extend <span style="font-family:monospace">ejabberd</span> with your own custom modules.
</li></ul>
</li><li class="li-itemize">Security
<ul class="itemize"><li class="li-itemize">
SASL and STARTTLS for c2s and s2s connections.
</li><li class="li-itemize">STARTTLS and Dialback s2s connections.
</li><li class="li-itemize">Web Admin accessible via HTTPS secure access.
</li></ul>
</li><li class="li-itemize">Databases
<ul class="itemize"><li class="li-itemize">
Internal database for fast deployment (Mnesia).
</li><li class="li-itemize">Native MySQL support.
</li><li class="li-itemize">Native PostgreSQL support.
</li><li class="li-itemize">ODBC data storage support.
</li><li class="li-itemize">Microsoft SQL Server support. </li><li class="li-itemize">Riak NoSQL database support.
</li></ul>
</li><li class="li-itemize">Authentication
<ul class="itemize"><li class="li-itemize">
Internal Authentication.
</li><li class="li-itemize">PAM, LDAP, ODBC and Riak. </li><li class="li-itemize">External Authentication script.
</li></ul>
</li><li class="li-itemize">Others
<ul class="itemize"><li class="li-itemize">
Support for virtual hosting.
</li><li class="li-itemize">Compressing XML streams with Stream Compression (<a href="http://www.xmpp.org/extensions/xep-0138.html">XEP-0138</a>).
</li><li class="li-itemize">Statistics via Statistics Gathering (<a href="http://www.xmpp.org/extensions/xep-0039.html">XEP-0039</a>).
</li><li class="li-itemize">IPv6 support both for c2s and s2s connections.
</li><li class="li-itemize"><a href="http://www.xmpp.org/extensions/xep-0045.html">Multi-User Chat</a> module with support for clustering and HTML logging. </li><li class="li-itemize">Users Directory based on users vCards.
</li><li class="li-itemize"><a href="http://www.xmpp.org/extensions/xep-0060.html">Publish-Subscribe</a> component with support for <a href="http://www.xmpp.org/extensions/xep-0163.html">Personal Eventing via Pubsub</a>.
</li><li class="li-itemize">Support for web clients: <a href="http://www.xmpp.org/extensions/xep-0025.html">HTTP Polling</a> and <a href="http://www.xmpp.org/extensions/xep-0206.html">HTTP Binding (BOSH)</a> services.
</li><li class="li-itemize">IRC transport.
</li><li class="li-itemize">SIP support.
</li><li class="li-itemize">Component support: interface with networks such as AIM, ICQ and MSN installing special tranports.
</li></ul>
</li></ul>
<!--TOC section id="sec4" How it Works-->
<h2 id="sec4" class="section">3&#XA0;&#XA0;How it Works</h2><!--SEC END --><p>
<a id="howitworks"></a></p><p>A XMPP domain is served by one or more <span style="font-family:monospace">ejabberd</span> nodes. These nodes can
be run on different machines that are connected via a network. They all must
have the ability to connect to port 4369 of all another nodes, and must have
the same magic cookie (see Erlang/OTP documentation, in other words the file
<span style="font-family:monospace">~ejabberd/.erlang.cookie</span> must be the same on all nodes). This is
needed because all nodes exchange information about connected users, S2S
connections, registered services, etc&#X2026;</p><p>Each <span style="font-family:monospace">ejabberd</span> node have following modules:
</p><ul class="itemize"><li class="li-itemize">
router;
</li><li class="li-itemize">local router.
</li><li class="li-itemize">session manager;
</li><li class="li-itemize">S2S manager;
</li></ul>
<!--TOC subsection id="sec5" Router-->
<h3 id="sec5" class="subsection">3.1&#XA0;&#XA0;Router</h3><!--SEC END --><p>This module is the main router of XMPP packets on each node. It routes
them based on their destinations domains. It has two tables: local and global
routes. First, domain of packet destination searched in local table, and if it
found, then the packet is routed to appropriate process. If no, then it
searches in global table, and is routed to the appropriate <span style="font-family:monospace">ejabberd</span> node or
process. If it does not exists in either tables, then it sent to the S2S
manager.</p>
<!--TOC subsection id="sec6" Local Router-->
<h3 id="sec6" class="subsection">3.2&#XA0;&#XA0;Local Router</h3><!--SEC END --><p>This module routes packets which have a destination domain equal to this server
name. If destination JID has a non-empty user part, then it routed to the
session manager, else it is processed depending on it&#X2019;s content.</p>
<!--TOC subsection id="sec7" Session Manager-->
<h3 id="sec7" class="subsection">3.3&#XA0;&#XA0;Session Manager</h3><!--SEC END --><p>This module routes packets to local users. It searches for what user resource
packet must be sent via presence table. If this resource is connected to
this node, it is routed to C2S process, if it connected via another node, then
the packet is sent to session manager on that node.</p>
<!--TOC subsection id="sec8" S2S Manager-->
<h3 id="sec8" class="subsection">3.4&#XA0;&#XA0;S2S Manager</h3><!--SEC END --><p>This module routes packets to other XMPP servers. First, it checks if an
open S2S connection from the domain of the packet source to the domain of
packet destination already exists. If it is open on another node, then it
routes the packet to S2S manager on that node, if it is open on this node, then
it is routed to the process that serves this connection, and if a connection
does not exist, then it is opened and registered.</p>
<!--TOC section id="sec9" Authentication-->
<h2 id="sec9" class="section">4&#XA0;&#XA0;Authentication</h2><!--SEC END -->
<!--TOC subsubsection id="sec10" External-->
<h4 id="sec10" class="subsubsection">4.0.1&#XA0;&#XA0;External</h4><!--SEC END --><p>
<a id="externalauth"></a>
</p><p>The external authentication script follows
<a href="http://www.erlang.org/doc/tutorial/c_portdriver.html">the erlang port driver API</a>.</p><p>That script is supposed to do theses actions, in an infinite loop:
</p><ul class="itemize"><li class="li-itemize">
read from stdin: AABBBBBBBBB.....
<ul class="itemize"><li class="li-itemize">
A: 2 bytes of length data (a short in network byte order)
</li><li class="li-itemize">B: a string of length found in A that contains operation in plain text
operation are as follows:
<ul class="itemize"><li class="li-itemize">
auth:User:Server:Password (check if a username/password pair is correct)
</li><li class="li-itemize">isuser:User:Server (check if it&#X2019;s a valid user)
</li><li class="li-itemize">setpass:User:Server:Password (set user&#X2019;s password)
</li><li class="li-itemize">tryregister:User:Server:Password (try to register an account)
</li><li class="li-itemize">removeuser:User:Server (remove this account)
</li><li class="li-itemize">removeuser3:User:Server:Password (remove this account if the password is correct)
</li></ul>
</li></ul>
</li><li class="li-itemize">write to stdout: AABB
<ul class="itemize"><li class="li-itemize">
A: the number 2 (coded as a short, which is bytes length of following result)
</li><li class="li-itemize">B: the result code (coded as a short), should be 1 for success/valid, or 0 for failure/invalid
</li></ul>
</li></ul><p>Example python script
</p><pre class="verbatim">#!/usr/bin/python

import sys
from struct import *

def from_ejabberd():
    input_length = sys.stdin.read(2)
    (size,) = unpack('&gt;h', input_length)
    return sys.stdin.read(size).split(':')

def to_ejabberd(bool):
    answer = 0
    if bool:
        answer = 1
    token = pack('&gt;hh', 2, answer)
    sys.stdout.write(token)
    sys.stdout.flush()

def auth(username, server, password):
    return True

def isuser(username, server):
    return True

def setpass(username, server, password):
    return True

while True:
    data = from_ejabberd()
    success = False
    if data[0] == "auth":
        success = auth(data[1], data[2], data[3])
    elif data[0] == "isuser":
        success = isuser(data[1], data[2])
    elif data[0] == "setpass":
        success = setpass(data[1], data[2], data[3])
    to_ejabberd(success)
</pre>
<!--TOC section id="sec11" XML Representation-->
<h2 id="sec11" class="section">5&#XA0;&#XA0;XML Representation</h2><!--SEC END --><p>
<a id="xmlrepr"></a></p><p>Each XML stanza is represented as the following tuple:
</p><pre class="verbatim">XMLElement = {xmlelement, Name, Attrs, [ElementOrCDATA]}
        Name = string()
        Attrs = [Attr]
        Attr = {Key, Val}
        Key = string()
        Val = string()
        ElementOrCDATA = XMLElement | CDATA
        CDATA = {xmlcdata, string()}
</pre><p>E.&#XA0;g. this stanza:
</p><pre class="verbatim">&lt;message to='test@conference.example.org' type='groupchat'&gt;
  &lt;body&gt;test&lt;/body&gt;
&lt;/message&gt;
</pre><p>is represented as the following structure:
</p><pre class="verbatim">{xmlelement, "message",
    [{"to", "test@conference.example.org"},
     {"type", "groupchat"}],
    [{xmlelement, "body",
         [],
         [{xmlcdata, "test"}]}]}}
</pre>
<!--TOC section id="sec12" Module <span style="font-family:monospace">xml</span>-->
<h2 id="sec12" class="section">6&#XA0;&#XA0;Module <span style="font-family:monospace">xml</span></h2><!--SEC END --><p>
<a id="xmlmod"></a></p><dl class="description"><dt class="dt-description">
</dt><dd class="dd-description"><code>element_to_string(El) -&gt; string()</code>
<pre class="verbatim">El = XMLElement
</pre>Returns string representation of XML stanza <span style="font-family:monospace">El</span>.</dd><dt class="dt-description"></dt><dd class="dd-description"><code>crypt(S) -&gt; string()</code>
<pre class="verbatim">S = string()
</pre>Returns string which correspond to <span style="font-family:monospace">S</span> with encoded XML special
characters.</dd><dt class="dt-description"></dt><dd class="dd-description"><code>remove_cdata(ECList) -&gt; EList</code>
<pre class="verbatim">ECList = [ElementOrCDATA]
EList = [XMLElement]
</pre><span style="font-family:monospace">EList</span> is a list of all non-CDATA elements of ECList.</dd><dt class="dt-description"></dt><dd class="dd-description"><code>get_path_s(El, Path) -&gt; Res</code>
<pre class="verbatim">El = XMLElement
Path = [PathItem]
PathItem = PathElem | PathAttr | PathCDATA
PathElem = {elem, Name}
PathAttr = {attr, Name}
PathCDATA = cdata
Name = string()
Res = string() | XMLElement
</pre>If <span style="font-family:monospace">Path</span> is empty, then returns <span style="font-family:monospace">El</span>. Else sequentially
consider elements of <span style="font-family:monospace">Path</span>. Each element is one of:
<dl class="description"><dt class="dt-description">
</dt><dd class="dd-description"><code>{elem, Name}</code> <span style="font-family:monospace">Name</span> is name of subelement of
<span style="font-family:monospace">El</span>, if such element exists, then this element considered in
following steps, else returns empty string.
</dd><dt class="dt-description"></dt><dd class="dd-description"><code>{attr, Name}</code> If <span style="font-family:monospace">El</span> have attribute <span style="font-family:monospace">Name</span>, then
returns value of this attribute, else returns empty string.
</dd><dt class="dt-description"></dt><dd class="dd-description"><code>cdata</code> Returns CDATA of <span style="font-family:monospace">El</span>.
</dd></dl></dd><dt class="dt-description"></dt><dd class="dd-description">TODO:
<pre class="verbatim">         get_cdata/1, get_tag_cdata/1
         get_attr/2, get_attr_s/2
         get_tag_attr/2, get_tag_attr_s/2
         get_subtag/2
</pre></dd></dl>
<!--TOC section id="sec13" Module <span style="font-family:monospace">xml_stream</span>-->
<h2 id="sec13" class="section">7&#XA0;&#XA0;Module <span style="font-family:monospace">xml_stream</span></h2><!--SEC END --><p>
<a id="xmlstreammod"></a></p><dl class="description"><dt class="dt-description">
</dt><dd class="dd-description"><code>parse_element(Str) -&gt; XMLElement | {error, Err}</code>
<pre class="verbatim">Str = string()
Err = term()
</pre>Parses <span style="font-family:monospace">Str</span> using XML parser, returns either parsed element or error
tuple.
</dd></dl>
<!--TOC section id="sec14" Modules-->
<h2 id="sec14" class="section">8&#XA0;&#XA0;Modules</h2><!--SEC END --><p>
<a id="emods"></a></p>
<!--TOC subsection id="sec15" Module gen_iq_handler-->
<h3 id="sec15" class="subsection">8.1&#XA0;&#XA0;Module gen_iq_handler</h3><!--SEC END --><p>
<a id="geniqhandl"></a></p><p>The module <code>gen_iq_handler</code> allows to easily write handlers for IQ packets
of particular XML namespaces that addressed to server or to users bare JIDs.</p><p>In this module the following functions are defined:
</p><dl class="description"><dt class="dt-description">
</dt><dd class="dd-description"><code>add_iq_handler(Component, Host, NS, Module, Function, Type)</code>
<pre class="verbatim">Component = Module = Function = atom()
Host = NS = string()
Type = no_queue | one_queue | parallel
</pre>Registers function <code>Module:Function</code> as handler for IQ packets on
virtual host <code>Host</code> that contain child of namespace <code>NS</code> in
<code>Component</code>. Queueing discipline is <code>Type</code>. There are at least
two components defined:
<dl class="description"><dt class="dt-description">
</dt><dd class="dd-description"><code>ejabberd_local</code> Handles packets that addressed to server JID;
</dd><dt class="dt-description"></dt><dd class="dd-description"><code>ejabberd_sm</code> Handles packets that addressed to users bare JIDs.
</dd></dl>
</dd><dt class="dt-description"></dt><dd class="dd-description"><code>remove_iq_handler(Component, Host, NS)</code>
<pre class="verbatim">Component = atom()
Host = NS = string()
</pre>Removes IQ handler on virtual host <code>Host</code> for namespace <code>NS</code> from
<code>Component</code>.
</dd></dl><p>Handler function must have the following type:
</p><dl class="description"><dt class="dt-description">
</dt><dd class="dd-description"><code>Module:Function(From, To, IQ)</code>
<pre class="verbatim">From = To = jid()
</pre></dd></dl><pre class="verbatim">-module(mod_cputime).

-behaviour(gen_mod).

-export([start/2,
         stop/1,
         process_local_iq/3]).

-include("ejabberd.hrl").
-include("jlib.hrl").

-define(NS_CPUTIME, "ejabberd:cputime").

start(Host, Opts) -&gt;
    IQDisc = gen_mod:get_opt(iqdisc, Opts, one_queue),
    gen_iq_handler:add_iq_handler(ejabberd_local, Host, ?NS_CPUTIME,
                                  ?MODULE, process_local_iq, IQDisc).

stop(Host) -&gt;
    gen_iq_handler:remove_iq_handler(ejabberd_local, Host, ?NS_CPUTIME).

process_local_iq(From, To, {iq, ID, Type, XMLNS, SubEl}) -&gt;
    case Type of
        set -&gt;
            {iq, ID, error, XMLNS,
             [SubEl, ?ERR_NOT_ALLOWED]};
        get -&gt;
            CPUTime = element(1, erlang:statistics(runtime))/1000,
            SCPUTime = lists:flatten(io_lib:format("~.3f", CPUTime)),
            {iq, ID, result, XMLNS,
             [{xmlelement, "query",
               [{"xmlns", ?NS_CPUTIME}],
               [{xmlelement, "cputime", [], [{xmlcdata, SCPUTime}]}]}]}
    end.
</pre>
<!--TOC subsection id="sec16" Services-->
<h3 id="sec16" class="subsection">8.2&#XA0;&#XA0;Services</h3><!--SEC END --><p>
<a id="services"></a></p><pre class="verbatim">-module(mod_echo).

-behaviour(gen_mod).

-export([start/2, init/1, stop/1]).

-include("ejabberd.hrl").
-include("jlib.hrl").

start(Host, Opts) -&gt;
    MyHost = gen_mod:get_opt(host, Opts, "echo." ++ Host),
    register(gen_mod:get_module_proc(Host, ?PROCNAME),
             spawn(?MODULE, init, [MyHost])).

init(Host) -&gt;
    ejabberd_router:register_local_route(Host),
    loop(Host).

loop(Host) -&gt;
    receive
        {route, From, To, Packet} -&gt;
            ejabberd_router:route(To, From, Packet),
            loop(Host);
        stop -&gt;
            ejabberd_router:unregister_route(Host),
            ok;
        _ -&gt;
            loop(Host)
    end.

stop(Host) -&gt;
    Proc = gen_mod:get_module_proc(Host, ?PROCNAME),
    Proc ! stop,
    {wait, Proc}.
</pre><!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<hr style="height:2"><blockquote class="quote"><em>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</em><a href="http://hevea.inria.fr/index.html"><em>H</em><em><span style="font-size:small"><sup>E</sup></span></em><em>V</em><em><span style="font-size:small"><sup>E</sup></span></em><em>A</em></a><em>.</em></blockquote></body>
</html>
